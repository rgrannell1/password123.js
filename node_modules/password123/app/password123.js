
"use strict"




const fs              = require('fs')
const path            = require('path')

const events          = require('events')
const crypto          = require('crypto')
const readline        = require('readline')

const utils           = require('password123/commons/utils')
const constants       = require('password123/commons/constants')





const displayMatch = match => {

	var message = match.hash.password

	if (match.hash.hash) {
		message += `    ${match.hash.hash}`
	}

	if (match.hash.digest) {
		message += `    ${match.hash.digest}`
	}

	console.log(message)

}





const readFileStream = (fpath, callback) => {

	const isReadableFlag = fs.R_OK
	const handledMessage = {
		[constants.errCodes.noEntry]:  ( ) => {
			return `ERROR: could not read from "${fpath}"; does the file exist?\n`
		},
		[constants.errCodes.noAccess]: ( ) => {
			return `ERROR: could not read from "${fpath}", as it isn't read-accessible.\n`
		}
	}

	fs.access(fpath, isReadableFlag, err => {

		if (err) {

			err.message = handledMessage.hasOwnProperty(err.code)
				? handledMessage[err.code]( )
				: err.message

			return callback(err, null)

		} else {

			return callback(null, fs.createReadStream(fpath))

		}


	})

}





const emitPasswordHashes = (passwordPath, hashesPath) => {

	var emitter = new events.EventEmitter( )

	readFileStream(hashesPath, (err, hashesStream) => {

		if (err) {
			// the hashes couldn't be read.

			if (err.code !== constants.errCodes.noEntry) {
				return emitter.emit(constants.events.error, err)
			}

			readFileStream(passwordPath, (err, passwordStream) => {
				// search the hashes and stream to a file at the same time.

				if (err) {
					return emitter.emit(constants.events.error, err)
				} else {

					const index = 0

					readline.createInterface({
						input: passwordStream
					})
					.on('line', emitPasswordHashes.calculateHashes.bind({ }, emitter))
					.on('close', ( ) => {
						emitter.emit(constants.events.close)
					})

				}

			})

		} else {
			// read from the file.

			readline.createInterface({
				input: hashesStream
			})
			.on('line', hashString => {
				emitter.emit(constants.events.oldHash, JSON.parse(hashString))
			})
			.on('close', ( ) => {
				emitter.emit(constants.events.close)
			})

		}

	})

	return emitter

}

{

	let hashDigestIndex = 0
	let passwordIndex   = 0

	emitPasswordHashes.calculateHashes = (emitter, password) => {

		emitter.emit(constants.events.newHash, {
			hash: {
				password,
				value:  password,
				digest: '',
				hash:   ''
			},
			hashDigestIndex,
			passwordIndex
		})

		++hashDigestIndex

		crypto.getHashes( ).forEach(hash => {
			constants.availableDigests.forEach(digest => {

				emitter.emit(constants.events.newHash, {
					hash: {
						password,
						value: crypto.createHash(hash).update(password).digest(digest),
						digest,
						hash
					},
					hashDigestIndex,
					passwordIndex
				})

				++hashDigestIndex

			})

		})

		++passwordIndex

		return emitter

	}

}





const password123 = rawArgs => {

	const args          = password123.preprocess(rawArgs)
	const emitter       = emitPasswordHashes(constants.paths.commonPasswords, constants.paths.commonPasswordsHashes)

	var writeStream     = null
	var unusedPasswords = args.passwords

	emitter.on(constants.events.newHash, hash => {

		if (!writeStream) {
			writeStream = fs.createWriteStream(constants.paths.commonPasswordsHashes)
		}

		writeStream.write(JSON.stringify(hash) + '\n')

	})

	emitter.on(constants.events.newHash, hash => {
		emitter.emit(constants.events.hash, hash)
	})

	emitter.on(constants.events.oldHash, hash => {
		emitter.emit(constants.events.hash, hash)
	})

	var passwords = {
		unused:  args.passwords,
		matches: [ ]
	}

	emitter.on(constants.events.hash, hash => {

		passwords.unused.forEach(password => {

			if (hash.hash.value === password) {

				displayMatch(hash)

				passwords.unused = passwords.unused.filter(otherPassword => {
					return otherPassword !== password
				})

			}

		})

	})

	emitter.on(constants.events.error, err => {
		process.stderr.write(`${err.message}\n`)
	})

	emitter.on(constants.events.close, ( ) => {

		passwords.unused.forEach(password => {
			console.log(password)
		})

		if (writeStream) {
			writeStream.end( )
		}

	})

}

password123.preprocess = rawArgs => {

	return {
		passwords:    rawArgs['<password>'],
		readSecurely: rawArgs['--secure'],
		hash:         rawArgs['--hash']
	}

}





module.exports = password123
