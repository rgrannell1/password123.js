
"use strict"




const fs              = require('fs')
const path            = require('path')

const events          = require('events')
const crypto          = require('crypto')
const readline        = require('readline')

const utils           = require('password123/commons/utils')
const constants       = require('password123/commons/constants')

const readFileStream  = require('password123/fs/read-file-stream')





const displayMatch = match => {

	var message = match.hash.password

	if (match.hash.hash) {
		message += `    ${match.hash.hash}`
	}

	if (match.hash.digest) {
		message += `    ${match.hash.digest}`
	}

	console.log(message)

}





const emitPasswordHashes = (passwordPath, hashesPath) => {

	var emitter = new events.EventEmitter( )

	readFileStream(hashesPath, (err, hashesStream) => {

		readline.createInterface({
			input: hashesStream
		})
		.on('line', hashString => {
			emitter.emit(constants.events.oldHash, JSON.parse(hashString))
		})
		.on('close', ( ) => {
			emitter.emit(constants.events.close)
		})

	})

	return emitter

}





{

	let hashDigestIndex = 0
	let passwordIndex   = 0

	emitPasswordHashes.calculateHashes = (emitter, password) => {

		emitter.emit(constants.events.newHash, {
			hash: {
				password,
				value:  password,
				digest: '',
				hash:   ''
			},
			hashDigestIndex,
			passwordIndex
		})

		++hashDigestIndex

		crypto.getHashes( ).forEach(hash => {
			constants.availableDigests.forEach(digest => {

				emitter.emit(constants.events.newHash, {
					hash: {
						password,
						value: crypto.createHash(hash).update(password).digest(digest),
						digest,
						hash
					},
					hashDigestIndex,
					passwordIndex
				})

				++hashDigestIndex

			})

		})

		++passwordIndex

		return emitter

	}

}





const password123 = rawArgs => {

	const args    = password123.preprocess(rawArgs)
	const emitter = emitPasswordHashes(constants.paths.commonPasswords, constants.paths.commonPasswordsHashes)

	emitter.on(constants.events.oldHash, hash => {
		emitter.emit(constants.events.hash, hash)
	})

	var passwords = {
		unused:  args.passwords,
		matches: [ ]
	}

	emitter.on(constants.events.hash, hash => {

		passwords.unused.forEach(password => {

			if (hash.hash.value === password) {

				displayMatch(hash)

				passwords.unused = passwords.unused.filter(otherPassword => {
					return otherPassword !== password
				})

			}

		})

	})

	emitter.on(constants.events.error, err => {
		process.stderr.write(`${err.message}\n`)
	})

	emitter.on(constants.events.close, ( ) => {
		passwords.unused.forEach(console.log)
	})

}

password123.preprocess = rawArgs => {

	return {
		passwords:    rawArgs['<password>'],
		readSecurely: rawArgs['--secure'],
		hash:         rawArgs['--hash']
	}

}





module.exports = password123
